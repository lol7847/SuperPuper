<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PROTOCOL: MAFIA // SECTOR 7</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --neon-green: #00ff9d;
            --neon-gold: #ffcc00;
            --bg-dark: #050510;
            --glass: rgba(0, 20, 40, 0.7);
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            font-family: 'Rajdhani', sans-serif;
            color: var(--neon-blue);
            height: 100vh; display: flex; flex-direction: column;
        }

        /* --- UI UTILS --- */
        .hidden { display: none !important; }
        h1, h2, h3 { font-family: 'Orbitron', sans-serif; text-transform: uppercase; margin: 0; letter-spacing: 2px; }
        
        button {
            background: rgba(0, 243, 255, 0.1); border: 1px solid var(--neon-blue);
            color: var(--neon-blue); padding: 12px 24px; font-family: 'Orbitron';
            cursor: pointer; transition: 0.3s; clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        button:hover { background: var(--neon-blue); color: #000; box-shadow: 0 0 15px var(--neon-blue); }
        button:disabled { border-color: #333; color: #555; pointer-events: none; }

        input {
            background: transparent; border: none; border-bottom: 2px solid var(--neon-blue);
            color: #fff; font-family: 'Orbitron'; font-size: 1.2rem; text-align: center;
            width: 80%; margin: 10px 0; outline: none;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: var(--bg-dark); z-index: 10; transition: opacity 0.5s;
        }

        /* --- GAME LAYOUT --- */
        #game-ui { position: relative; width: 100%; height: 100%; overflow: hidden; }

        /* HEADER INFO */
        .top-bar {
            position: absolute; top: 0; left: 0; width: 100%; padding: 15px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            z-index: 5; pointer-events: none;
        }
        .role-badge {
            border: 1px solid var(--neon-gold); color: var(--neon-gold);
            padding: 5px 15px; font-weight: bold; font-family: 'Orbitron';
            background: rgba(0,0,0,0.8); pointer-events: auto;
        }

        /* CENTER TABLE (REACTOR) */
        .table-container {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 300px; height: 300px;
            border-radius: 50%;
            border: 2px dashed var(--neon-blue);
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            animation: spin 60s linear infinite;
        }
        @keyframes spin { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        /* STATIONARY INFO INSIDE TABLE */
        .reactor-core {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; z-index: 4;
            width: 200px;
        }
        #timer-display { font-size: 4rem; color: #fff; text-shadow: 0 0 20px #fff; font-family: 'Orbitron'; }
        #phase-display { font-size: 1.2rem; color: var(--neon-green); letter-spacing: 3px; }

        /* PLAYERS ORBIT */
        .player-orbit {
            position: absolute; width: 100%; height: 100%;
            top: 0; left: 0; pointer-events: none;
        }
        .player-node {
            position: absolute; width: 80px; height: 80px;
            /* Centering logic handled in JS */
            transform: translate(-50%, -50%);
            pointer-events: auto; cursor: pointer;
            display: flex; flex-direction: column; align-items: center;
            transition: 0.3s;
        }
        .node-circle {
            width: 60px; height: 60px; border-radius: 50%;
            background: #000; border: 2px solid #333;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.5rem; color: #555;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
            position: relative;
        }
        .player-node.alive .node-circle { border-color: var(--neon-blue); color: #fff; box-shadow: 0 0 15px var(--neon-blue); }
        .player-node.dead .node-circle { border-color: var(--neon-red); color: var(--neon-red); opacity: 0.5; }
        .player-node.selected .node-circle { background: var(--neon-gold); color: #000; box-shadow: 0 0 25px var(--neon-gold); }
        
        .node-name { margin-top: 5px; font-size: 0.8rem; text-shadow: 0 0 5px #000; background: rgba(0,0,0,0.6); padding: 2px 5px; }

        /* CHAT MODULE */
        .comms-panel {
            position: absolute; bottom: 0; left: 0; width: 100%; height: 25%;
            background: rgba(0, 10, 20, 0.9); border-top: 1px solid var(--neon-blue);
            display: flex; flex-direction: column;
            z-index: 20;
        }
        .chat-log { flex: 1; overflow-y: auto; padding: 10px; font-family: monospace; font-size: 0.9rem; text-align: left; }
        .chat-entry { display: flex; border-top: 1px solid #333; }
        .chat-entry input { width: 100%; margin: 0; border: none; padding: 10px; text-align: left; }
        .chat-msg { margin-bottom: 4px; }
        .sys-msg { color: var(--neon-gold); font-style: italic; }

        /* VOICE BUTTON */
        #voice-btn {
            position: absolute; bottom: 26%; right: 10px;
            width: 50px; height: 50px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 24px; padding: 0; z-index: 25;
            background: #000; border-color: var(--neon-green);
        }
        #voice-btn.active { background: var(--neon-green); color: #000; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(0,255,157, 0.4); } 70% { box-shadow: 0 0 0 10px rgba(0,255,157, 0); } 100% { box-shadow: 0 0 0 0 rgba(0,255,157, 0); } }

        /* OVERLAYS */
        .overlay-msg {
            position: absolute; top: 30%; width: 100%; text-align: center;
            font-size: 2rem; color: var(--neon-red); text-shadow: 0 0 10px var(--neon-red);
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 30;
        }
    </style>
</head>
<body>

    <!-- 1. MAIN MENU -->
    <div id="screen-menu" class="screen">
        <h1 style="font-size: 3rem; color: var(--neon-blue); text-shadow: 0 0 20px var(--neon-blue);">MAFIA 2077</h1>
        <br>
        <input type="text" id="username" placeholder="IDENTIFICATION" maxlength="12">
        <br>
        <button onclick="initHost()">INITIALIZE HOST</button>
        <div style="margin: 20px 0; display:flex; gap:10px;">
            <input type="text" id="join-id" placeholder="UPLINK ID" style="margin:0; width: 150px;">
            <button onclick="joinGame()" style="padding: 10px;">CONNECT</button>
        </div>
        <p id="menu-status" style="color: var(--neon-gold); font-size: 0.8rem;"></p>
    </div>

    <!-- 2. LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <h2>PRE-FLIGHT CHECK</h2>
        <div style="background: #000; padding: 10px; border: 1px dashed var(--neon-blue); cursor: pointer;" onclick="copyId()">
            <span id="lobby-id" style="font-family: monospace;">GENERATING...</span>
        </div>
        <div id="lobby-list" style="margin: 30px 0; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;"></div>
        <button id="start-btn" onclick="startGame()" disabled>ENGAGE SEQUENCE</button>
        <p>WAITING FOR CREW (MIN 3)</p>
    </div>

    <!-- 3. GAME UI -->
    <div id="screen-game" class="screen hidden" style="display: block;">
        
        <div class="top-bar">
            <div>SECTOR 7 // <span id="day-counter">DAY 1</span></div>
            <div id="role-badge" class="role-badge">LOADING...</div>
        </div>

        <div class="overlay-msg" id="alert-overlay">SYSTEM ALERT</div>

        <!-- CENTER TABLE -->
        <div class="table-container"></div>
        
        <!-- STATIONARY CENTER -->
        <div class="reactor-core">
            <div id="timer-display">00</div>
            <div id="phase-display">STANDBY</div>
        </div>

        <!-- PLAYERS -->
        <div id="orbit-container" class="player-orbit"></div>

        <!-- VOICE TOGGLE -->
        <button id="voice-btn" onclick="toggleVoice()">ðŸŽ¤</button>

        <!-- CHAT -->
        <div class="comms-panel">
            <div id="chat-log" class="chat-log"></div>
            <div class="chat-entry">
                <input type="text" id="chat-input" placeholder="TRANSMIT MESSAGE..." onkeydown="if(event.key==='Enter') sendChat()">
                <button onclick="sendChat()" style="width: auto; padding: 0 20px;">></button>
            </div>
        </div>
    </div>

    <script>
        // --- CONSTANTS & CONFIG ---
        const ROLES = ['Mafia', 'Doctor', 'Detective', 'Villager', 'Villager', 'Mafia', 'Villager', 'Villager'];
        const TIMERS = {
            INTRO: 5,
            NIGHT: 20,
            DAY: 45
        };

        // --- GLOBAL STATE ---
        let peer, conn;
        let myId, myName;
        let isHost = false;
        let connections = []; // Host only
        let myStream = null;  // Audio
        
        // Game State
        let players = []; // { id, name, role, isAlive, lastHealedRound }
        let gameState = {
            phase: 'lobby', // lobby, intro, night, day, gameover
            timer: 0,
            dayCount: 1,
            actions: {} // { mafia: id, doctor: id, detective: id, votes: { voterId: targetId } }
        };
        
        let interval = null;

        // --- PEERJS SETUP ---
        function initPeer(cb) {
            document.getElementById('menu-status').innerText = "ESTABLISHING UPLINK...";
            peer = new Peer();
            peer.on('open', (id) => {
                myId = id;
                document.getElementById('menu-status').innerText = "";
                cb(id);
            });
            peer.on('error', err => alert("UPLINK FAILED: " + err.type));
            
            // Voice handling (Receiver)
            peer.on('call', (call) => {
                call.answer(myStream); // Answer with our stream if available
                call.on('stream', remoteStream => {
                    const audio = new Audio();
                    audio.srcObject = remoteStream;
                    audio.play();
                });
            });
        }

        // --- VOICE CHAT (BASIC) ---
        async function toggleVoice() {
            const btn = document.getElementById('voice-btn');
            if(myStream) {
                // Mute/Stop
                myStream.getTracks().forEach(t => t.stop());
                myStream = null;
                btn.classList.remove('active');
            } else {
                try {
                    myStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    btn.classList.add('active');
                    // In a mesh network, we'd call everyone. 
                    // Simplified: Call Host if client, Call everyone if Host.
                    if(!isHost && conn) {
                        peer.call(conn.peer, myStream);
                    } else if(isHost) {
                        connections.forEach(c => peer.call(c.peer, myStream));
                    }
                } catch(e) {
                    alert("MICROPHONE ACCESS DENIED");
                }
            }
        }

        // --- HOST LOGIC ---
        function initHost() {
            myName = document.getElementById('username').value.trim() || "COMMANDER";
            isHost = true;
            initPeer((id) => {
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-lobby').classList.remove('hidden');
                document.getElementById('lobby-id').innerText = id;
                
                players.push({ id: myId, name: myName, role: null, isAlive: true, lastHealedRound: 0 });
                updateLobby();

                peer.on('connection', (c) => {
                    connections.push(c);
                    c.on('data', (data) => handleHostData(data, c.peer));
                    c.on('close', () => {
                        players = players.filter(p => p.id !== c.peer);
                        connections = connections.filter(x => x.peer !== c.peer);
                        updateLobby();
                        broadcastState();
                    });
                });
            });
        }

        function handleHostData(data, senderId) {
            if(data.type === 'join') {
                players.push({ id: senderId, name: data.name, role: null, isAlive: true, lastHealedRound: 0 });
                updateLobby();
                broadcastState();
            } else if (data.type === 'action') {
                handleGameAction(senderId, data.payload);
            } else if (data.type === 'chat') {
                broadcastChat(data.name, data.msg);
            }
        }

        function updateLobby() {
            const list = document.getElementById('lobby-list');
            list.innerHTML = players.map(p => `<div style="background:#111; color:var(--neon-blue); padding:5px 10px; border:1px solid var(--neon-blue);">${p.name}</div>`).join('');
            document.getElementById('start-btn').disabled = players.length < 3;
        }

        function startGame() {
            if(players.length < 3) return;
            // Assign Roles
            let deck = ROLES.slice(0, players.length).sort(() => Math.random() - 0.5);
            players.forEach((p, i) => p.role = deck[i]);
            
            document.getElementById('screen-lobby').classList.add('hidden');
            document.getElementById('screen-game').classList.remove('hidden');
            
            // START LOOP
            runPhase('intro');
        }

        // --- GAME LOOP (HOST) ---
        function runPhase(phase) {
            gameState.phase = phase;
            gameState.actions = { votes: {} }; // Reset actions
            
            let duration = 0;
            let msg = "";

            if(phase === 'intro') {
                duration = TIMERS.INTRO;
                msg = "INITIALIZING SEQUENCE...";
            } else if (phase === 'night') {
                duration = TIMERS.NIGHT;
                msg = "NIGHT CYCLE. ROLES ENGAGE.";
            } else if (phase === 'day') {
                duration = TIMERS.DAY;
                msg = "DAY CYCLE. DELIBERATE.";
            }

            gameState.timer = duration;
            broadcastState(msg);

            // Timer Logic
            if(interval) clearInterval(interval);
            interval = setInterval(() => {
                gameState.timer--;
                
                // Sync timer occasionally to keep clients aligned without spamming
                if(gameState.timer % 5 === 0 || gameState.timer <= 5) {
                    broadcastTimer();
                }

                if(gameState.timer <= 0) {
                    clearInterval(interval);
                    nextPhase();
                }
            }, 1000);
        }

        function nextPhase() {
            if(gameState.phase === 'intro') {
                runPhase('night');
            } else if (gameState.phase === 'night') {
                resolveNight();
            } else if (gameState.phase === 'day') {
                resolveDay();
            }
        }

        function resolveNight() {
            let msg = "SUNRISE. ";
            const mafiaTarget = gameState.actions.mafia;
            const docTarget = gameState.actions.doctor;
            
            // Logic
            if(mafiaTarget) {
                if(mafiaTarget === docTarget) {
                    msg += "ATTACK INTERCEPTED. TARGET STABILIZED.";
                } else {
                    const victim = players.find(p => p.id === mafiaTarget);
                    if(victim) {
                        victim.isAlive = false;
                        msg += `CASUALTY REPORT: ${victim.name} ELIMINATED.`;
                    }
                }
            } else {
                msg += "NO HOSTILE ACTIVITY DETECTED.";
            }

            if(checkWinCondition()) return;
            runPhase('day');
            // Send alert after phase change so UI updates first
            setTimeout(() => broadcastAlert(msg), 500);
        }

        function resolveDay() {
            // Count votes
            const counts = {};
            Object.values(gameState.actions.votes).forEach(t => counts[t] = (counts[t] || 0) + 1);
            
            let max = 0;
            let elimId = null;
            for(const [id, c] of Object.entries(counts)) {
                if(c > max) { max = c; elimId = id; }
            }

            let msg = "VOTE INCONCLUSIVE.";
            // Require at least 2 votes to kill
            if(elimId && max > 1) {
                const victim = players.find(p => p.id === elimId);
                if(victim) {
                    victim.isAlive = false;
                    msg = `CREW DECISION: ${victim.name} EJECTED.`;
                }
            }

            if(checkWinCondition()) return;
            
            gameState.dayCount++;
            runPhase('night');
            setTimeout(() => broadcastAlert(msg), 500);
        }

        function checkWinCondition() {
            const mafiaCount = players.filter(p => p.isAlive && p.role === 'Mafia').length;
            const villagerCount = players.filter(p => p.isAlive && p.role !== 'Mafia').length;

            if(mafiaCount === 0) {
                endGame("VILLAGERS WIN - SECTOR SECURE");
                return true;
            }
            if(mafiaCount >= villagerCount) {
                endGame("MAFIA WINS - SECTOR COMPROMISED");
                return true;
            }
            return false;
        }

        function endGame(result) {
            gameState.phase = 'gameover';
            broadcastState(result);
            broadcastAlert(result);
        }

        function handleGameAction(actorId, targetId) {
            if(gameState.phase === 'gameover') return;

            const actor = players.find(p => p.id === actorId);
            if(!actor || !actor.isAlive) return;

            if(gameState.phase === 'night') {
                if(actor.role === 'Mafia') {
                    gameState.actions.mafia = targetId;
                }
                if(actor.role === 'Doctor') {
                    // DOCTOR CONSTRAINT: Cannot heal same person twice in a row
                    if(actor.lastHealedRound === gameState.dayCount && actor.lastHealedTarget === targetId) {
                        sendPrivate(actorId, "ERROR: RECHARGE CYCLE ACTIVE (1 ROUND)");
                        return;
                    }
                    gameState.actions.doctor = targetId;
                    actor.lastHealedRound = gameState.dayCount; // Mark round
                    actor.lastHealedTarget = targetId; // Mark target
                }
                if(actor.role === 'Detective') {
                    const target = players.find(p => p.id === targetId);
                    const isMafia = target.role === 'Mafia';
                    sendPrivate(actorId, `SCAN RESULT: ${target.name} is ${isMafia ? 'HOSTILE' : 'FRIENDLY'}`);
                }
            } else if (gameState.phase === 'day') {
                gameState.actions.votes[actorId] = targetId;
            }
        }

        // --- NETWORKING UTILS ---
        function broadcastState(alertMsg = null) {
            const publicPlayers = players.map(p => ({
                id: p.id, name: p.name, isAlive: p.isAlive
            }));
            const payload = {
                type: 'state',
                players: publicPlayers,
                phase: gameState.phase,
                timer: gameState.timer,
                day: gameState.dayCount,
                alert: alertMsg
            };
            
            // Update Host UI
            updateGameUI(payload, players.find(p=>p.id===myId).role);
            if(alertMsg) showAlert(alertMsg);

            connections.forEach(c => {
                const p = players.find(x => x.id === c.peer);
                c.send({ ...payload, myRole: p ? p.role : 'Spectator' });
            });
        }

        function broadcastTimer() {
            const data = { type: 'timer', time: gameState.timer };
            updateTimerUI(gameState.timer);
            connections.forEach(c => c.send(data));
        }

        function broadcastAlert(msg) {
            showAlert(msg);
            connections.forEach(c => c.send({ type: 'alert', msg }));
        }

        function broadcastChat(name, msg) {
            const data = { type: 'chat', name, msg };
            addLog(name, msg);
            connections.forEach(c => c.send(data));
        }

        function sendPrivate(targetId, msg) {
            if(targetId === myId) showAlert(msg);
            else {
                const c = connections.find(x => x.peer === targetId);
                if(c) c.send({ type: 'alert', msg });
            }
        }

        // --- CLIENT LOGIC ---
        function joinGame() {
            myName = document.getElementById('username').value.trim() || "CADET";
            const hostId = document.getElementById('join-id').value.trim();
            if(!hostId) return;

            initPeer((id) => {
                conn = peer.connect(hostId);
                conn.on('open', () => {
                    document.getElementById('menu-status').innerText = "UPLINK SECURE.";
                    conn.send({ type: 'join', name: myName });
                });
                conn.on('data', data => {
                    if(data.type === 'state') {
                        if(document.getElementById('screen-game').classList.contains('hidden')) {
                            document.getElementById('screen-menu').classList.add('hidden');
                            document.getElementById('screen-game').classList.remove('hidden');
                        }
                        updateGameUI(data, data.myRole);
                        if(data.alert) showAlert(data.alert);
                    }
                    else if (data.type === 'timer') updateTimerUI(data.time);
                    else if (data.type === 'alert') showAlert(data.msg);
                    else if (data.type === 'chat') addLog(data.name, data.msg);
                });
            });
        }

        // --- RENDERER ---
        let selectedTarget = null;

        function updateGameUI(state, myRole) {
            document.getElementById('day-counter').innerText = `CYCLE ${state.day}`;
            document.getElementById('role-badge').innerText = myRole;
            document.getElementById('phase-display').innerText = state.phase.toUpperCase();
            updateTimerUI(state.timer);

            // Render Circular Layout
            const orbit = document.getElementById('orbit-container');
            orbit.innerHTML = '';
            
            const total = state.players.length;
            const radius = 150; // Distance from center (px) - mobile friendly approx
            
            state.players.forEach((p, index) => {
                // Math for circle
                const angle = (index / total) * 2 * Math.PI - (Math.PI/2); // Start at top
                const x = 50 + (35 * Math.cos(angle)); // % units for responsiveness
                const y = 50 + (35 * Math.sin(angle));
                
                const node = document.createElement('div');
                node.className = `player-node ${p.isAlive ? 'alive' : 'dead'} ${selectedTarget === p.id ? 'selected' : ''}`;
                node.style.left = `${x}%`;
                node.style.top = `${y}%`;
                
                node.innerHTML = `
                    <div class="node-circle" onclick="clickPlayer('${p.id}', ${p.isAlive})">
                        ${p.name.charAt(0).toUpperCase()}
                    </div>
                    <div class="node-name">${p.name}</div>
                `;
                orbit.appendChild(node);
            });
        }

        function updateTimerUI(time) {
            document.getElementById('timer-display').innerText = time;
            if(time <= 5) document.getElementById('timer-display').style.color = "var(--neon-red)";
            else document.getElementById('timer-display').style.color = "#fff";
        }

        function clickPlayer(id, isAlive) {
            if(!isAlive) return;
            selectedTarget = id;
            // Visual Update locally immediately
            document.querySelectorAll('.player-node').forEach(el => el.classList.remove('selected'));
            // This is a dirty hack to re-highlight without waiting for server, relies on DOM structure
            // In production, use React/Vue. Here we just wait for next tick or user interaction.
            // But let's send the action immediately.
            submitAction(id);
        }

        function submitAction(targetId) {
            if(isHost) handleGameAction(myId, targetId);
            else conn.send({ type: 'action', payload: targetId });
            
            // Highlight visually (simple way)
            // Note: In a real app we'd wait for state update, but here we want instant feedback
        }

        // --- CHAT & UTILS ---
        function sendChat() {
            const input = document.getElementById('chat-input');
            const msg = input.value.trim();
            if(!msg) return;
            
            if(isHost) broadcastChat(myName, msg);
            else conn.send({ type: 'chat', name: myName, msg: msg });
            
            input.value = "";
        }

        function addLog(name, msg) {
            const log = document.getElementById('chat-log');
            const entry = document.createElement('div');
            entry.className = 'chat-msg';
            entry.innerHTML = `<span style="color:var(--neon-green)">${name}:</span> ${msg}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
        }

        function showAlert(msg) {
            const el = document.getElementById('alert-overlay');
            el.innerText = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 4000);
        }

        function copyId() {
            const txt = document.getElementById('lobby-id').innerText;
            navigator.clipboard.writeText(txt).then(() => alert("ID COPIED"));
        }
    </script>
</body>
</html>
