<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SCRAP QUOTA: MULTIPLAYER</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
        
        body { margin: 0; overflow: hidden; background: #050505; font-family: 'VT323', monospace; user-select: none; }

        /* UI LAYOUT */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 25px; box-sizing: border-box; color: #33ff00; text-shadow: 0 0 4px rgba(51, 255, 0, 0.6); z-index: 10; }
        .hud-row { display: flex; justify-content: space-between; font-size: 28px; background: linear-gradient(90deg, rgba(0,20,0,0) 0%, rgba(0,20,0,0.6) 50%, rgba(0,20,0,0) 100%); padding: 5px 20px; }

        #crosshair { position: absolute; top: 50%; left: 50%; width: 4px; height: 4px; background: #33ff00; transform: translate(-50%, -50%); border-radius: 50%; pointer-events: none; box-shadow: 0 0 6px #33ff00; opacity: 0.8; }

        #notification { align-self: center; font-size: 36px; display: none; background: rgba(0,0,0,0.8); padding: 10px 20px; border: 1px solid #33ff00; }
        .red-text { color: #ff3300; text-shadow: 0 0 5px #ff3300; border-color: #ff3300 !important; }
        #interact-msg { position: absolute; top: 58%; left: 50%; transform: translate(-50%, -50%); font-size: 22px; color: #fff; text-shadow: 0 0 2px #000; display: none; }
        #bonus-timer { align-self: center; font-size: 60px; display: none; color: #00ffff; text-shadow: 0 0 10px #00ffff; }

        #terminal, #pause-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: #000; color: #33ff00; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; font-size: 24px; }
        #pause-overlay { background: rgba(0,0,0,0.6); display: none; z-index: 15; }

        button { background: #000; border: 2px solid #33ff00; color: #33ff00; padding: 15px 40px; font-family: inherit; font-size: 28px; cursor: pointer; margin-top: 30px; transition: all 0.2s; }
        button:hover { background: #33ff00; color: #000; box-shadow: 0 0 15px #33ff00; }
        button:disabled { border-color: #555; color: #555; cursor: not-allowed; }
        
        input { background: #000; border: 1px solid #33ff00; color: #33ff00; padding: 10px; font-family: inherit; font-size: 24px; width: 300px; text-align: center; margin-bottom: 10px; }

        .hidden { display: none !important; }
        #loading-msg { color: yellow; font-size: 18px; margin-top: 15px; display:none; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }

        #energy-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 12; pointer-events: none; display: none; background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,100,255,0.4) 100%); animation: pulse 1s infinite alternate; }
        @keyframes pulse {
            from { transform: scale(1); background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,100,255,0.4) 100%); }
            to { transform: scale(1.1); background: radial-gradient(circle, rgba(0,0,0,0) 0%, rgba(0,200,255,0.6) 100%); }
        }
        
        #multiplayer-menu { margin-top: 20px; text-align: center; border: 1px solid #33ff00; padding: 20px; background: rgba(0,20,0,0.5); }
        .mp-row { display: flex; gap: 10px; justify-content: center; align-items: center; margin-top: 10px; }
        #my-id { font-size: 20px; color: #ffff00; user-select: text; cursor: text; margin-top: 10px; }
    </style>
    
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="crosshair"></div>
<div id="interact-msg">[E] INTERACT</div>
<div id="energy-overlay"></div>

<div id="ui-layer" class="hidden">
    <div class="hud-row">
        <div>QUOTA: <span id="hud-money">0</span> / <span id="hud-quota">130</span></div>
        <div id="hud-time">08:00</div>
    </div>
    <div id="bonus-timer"></div>
    <div id="notification"></div>
    <div class="hud-row" style="align-items: flex-end;">
        <div>WEIGHT: <span id="hud-weight">0</span> lbs<br>STAMINA: <span id="hud-stamina">100</span>%</div>
        <div style="text-align: right; font-size: 20px;">
            <div style="margin-bottom:5px; text-decoration: underline;">INVENTORY</div>
            <div id="hud-inventory">EMPTY HANDS</div>
        </div>
    </div>
</div>

<div id="pause-overlay"><h1>PAUSED</h1><p>CLICK TO RESUME</p></div>

<div id="terminal">
    <h1 style="font-size: 72px; margin: 0; text-shadow: 0 0 10px #33ff00;">SCRAP QUOTA</h1>
    <h2 style="color:#fff; opacity: 0.8;">OPERATON: FROSTBITE</h2>
    
    <div id="multiplayer-menu">
        <div style="text-decoration: underline;">MULTIPLAYER</div>
        <div class="mp-row">
            <button id="host-btn" style="margin:0; padding: 5px 15px; font-size: 20px;">HOST</button>
            <span>OR</span>
            <input type="text" id="join-id-input" placeholder="Enter Host ID">
            <button id="join-btn" style="margin:0; padding: 5px 15px; font-size: 20px;">JOIN</button>
        </div>
        <div id="my-id">Status: Offline</div>
    </div>

    <div id="loading-msg">LOADING ASSETS...</div>
    <button id="start-btn">LAND SHIP</button>
    <div style="margin-top: 30px; font-size: 18px; color: #888;">[WASD] MOVE • [SHIFT] SPRINT • [E] INTERACT • [G] DROP • [F] USE ITEM</div>
</div>

<script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // 1. CONFIGURATION
    const MODELS = {
        scrapFiles: [ 'trash_1.glb', 'trash_2.glb' ],
        enemy: 'Monster.glb',
        player: 'Player.glb',
        energy: 'Energy.glb'
    };
    const MODEL_SCALE = 1.0;
    
    const GAME_CONFIG = { tileSize: 10, mapSize: 40, wallHeight: 12, snowCount: 6000 };
    const gameState = { inMenu: true, money: 0, quota: 130, days: 3, time: 8 * 60, gameOver: false };
    const player = { speed: 8.0, runSpeed: 15.0, velocity: new THREE.Vector3(), stamina: 100, inventory: [], weight: 0, maxSlots: 4, hasEnergyDrink: false };
    const energyEffect = { active: false, timer: 0, bonusWorldTimer: 0, music: null };

    // Network
    let peer = null;
    let conn = null;
    let myPeerId = null;
    let remotePlayers = {}; // { id: Mesh }

    let walls = [], scraps = [], enemies = [], mines = [], bonusScraps = [], energyDrinkObject;
    let worldObjects = new THREE.Group(); 
    let shipZone = new THREE.Box3();
    let leverMesh;
    let snowSystem, sparkleSystem;

    // 2. ENGINE SETUP
    const scene = new THREE.Scene();
    const defaultBgColor = new THREE.Color(0x020205);
    scene.background = defaultBgColor;
    scene.fog = new THREE.FogExp2(0x020205, 0.035);
    scene.add(worldObjects);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.rotation.order = 'YXZ';

    const renderer = new THREE.WebGLRenderer({ antialias: false });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const listener = new THREE.AudioListener(); camera.add(listener);

    const ambientLight = new THREE.AmbientLight(0x1a1a25, 0.5); 
    scene.add(ambientLight);

    const flashLight = new THREE.SpotLight(0xffffee, 300);
    flashLight.angle = Math.PI / 5; flashLight.penumbra = 0.3; flashLight.decay = 2; flashLight.distance = 80;
    camera.add(flashLight); flashLight.position.set(0, 0, 0); flashLight.target.position.set(0, 0, -1);
    camera.add(flashLight.target); scene.add(camera);

    const texLoader = new THREE.TextureLoader();
    const safeTexLoad = (url) => texLoader.load(url, (t) => { t.colorSpace = THREE.SRGBColorSpace; t.flipY = false; }, undefined, () => {});
    
    const scrapTexture = safeTexLoad('Scrap_Texture.png');
    const energyTexture = safeTexLoad('Texture_Energy.png');
    const warpBgTexture = safeTexLoad('https://i.imgur.com/h4u8s95.jpeg');
    const bonusBgTexture = safeTexLoad('https://i.imgur.com/T0Et3b4.jpeg');
    let energyMusicBuffer = null;

    const matWall = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.7 });
    const matFloor = new THREE.MeshStandardMaterial({ color: 0xdddddd, roughness: 0.9 });
    const matBonusFloor = new THREE.MeshStandardMaterial({ color: 0x051025, roughness: 0.8 });
    const matShip = new THREE.MeshStandardMaterial({ color: 0xaa8800, roughness: 0.4 });
    const matLever = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const matMineBase = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5 });
    
    let moveF = false, moveB = false, moveL = false, moveR = false, sprint = false;
    const raycaster = new THREE.Raycaster(); const center = new THREE.Vector2(0, 0);

    // 3. EFFECTS (Snow & Sparkles)
    function createEffects() {
        // Snow
        const snowGeo = new THREE.BufferGeometry();
        const snowVerts = [];
        const range = GAME_CONFIG.mapSize * GAME_CONFIG.tileSize;
        for (let i = 0; i < GAME_CONFIG.snowCount; i++) snowVerts.push(Math.random()*range-range/2, Math.random()*50, Math.random()*range-range/2);
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowVerts, 3));
        snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.8 }));
        scene.add(snowSystem);

        // Sparkles (Trip Effect)
        const sparkGeo = new THREE.BufferGeometry();
        const sparkVerts = [];
        const colors = [];
        for (let i = 0; i < 2000; i++) {
            sparkVerts.push((Math.random()-0.5)*100, (Math.random()-0.5)*50, (Math.random()-0.5)*100);
            const c = new THREE.Color().setHSL(Math.random(), 1.0, 0.5);
            colors.push(c.r, c.g, c.b);
        }
        sparkGeo.setAttribute('position', new THREE.Float32BufferAttribute(sparkVerts, 3));
        sparkGeo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        sparkleSystem = new THREE.Points(sparkGeo, new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true, opacity: 0 }));
        scene.add(sparkleSystem);
    }
    
    function updateEffects(delta) {
        // Snow
        if (snowSystem) {
            const pos = snowSystem.geometry.attributes.position.array;
            for (let i = 1; i < pos.length; i += 3) { pos[i] -= 0.15; if (pos[i] < 0) pos[i] = 50; }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }
        // Sparkles
        if (sparkleSystem && energyEffect.active) {
            sparkleSystem.material.opacity = Math.min(1, sparkleSystem.material.opacity + delta);
            const pos = sparkleSystem.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i+=3) {
                pos[i+1] += delta * 2; // Float up
                pos[i] += (Math.random()-0.5)*0.1; // Jitter
                if(pos[i+1] > 20) pos[i+1] = -10;
            }
            sparkleSystem.geometry.attributes.position.needsUpdate = true;
        } else if (sparkleSystem) {
            sparkleSystem.material.opacity = 0;
        }
    }

    // 4. ASSET LOADING
    const loadedAssets = { scraps: [], enemy: null, player: null, energy: null };
    const gltfLoader = new GLTFLoader();
    const audioLoader = new THREE.AudioLoader();

    function loadAssets() {
        const status = document.getElementById('loading-msg');
        const startBtn = document.getElementById('start-btn');
        startBtn.disabled = true;
        
        const safeLoadGLTF = (url, onSuccess) => new Promise(resolve => gltfLoader.load(url, (g)=>{onSuccess(g);resolve();}, undefined, ()=>{console.warn("Missing:",url);resolve();}));
        const promises = [];

        MODELS.scrapFiles.forEach(url => promises.push(safeLoadGLTF(url, g => {
            g.scene.traverse(c=>{if(c.isMesh)c.material.map=scrapTexture;}); loadedAssets.scraps.push(g.scene);
        })));
        if(MODELS.enemy) promises.push(safeLoadGLTF(MODELS.enemy, g => loadedAssets.enemy = g.scene));
        if(MODELS.player) promises.push(safeLoadGLTF(MODELS.player, g => loadedAssets.player = g.scene));
        if(MODELS.energy) promises.push(safeLoadGLTF(MODELS.energy, g => {
            g.scene.traverse(c=>{if(c.isMesh)c.material.map=energyTexture;}); loadedAssets.energy = g.scene;
        }));
        promises.push(new Promise(r => audioLoader.load('Energy_Music.mp3', b=>{energyMusicBuffer=b;r();}, undefined, r)));

        Promise.all(promises).then(() => {
            status.style.display = 'none';
            startBtn.disabled = false;
        });
    }
    loadAssets();

    // 5. MULTIPLAYER LOGIC
    document.getElementById('host-btn').addEventListener('click', () => {
        peer = new Peer();
        peer.on('open', (id) => {
            myPeerId = id;
            document.getElementById('my-id').innerText = `ID: ${id} (Waiting...)`;
            document.getElementById('my-id').style.color = '#33ff00';
        });
        peer.on('connection', (c) => {
            conn = c;
            setupConnection();
            alert("Player Joined!");
        });
    });

    document.getElementById('join-btn').addEventListener('click', () => {
        const id = document.getElementById('join-id-input').value;
        if(!id) return;
        peer = new Peer();
        peer.on('open', () => {
            conn = peer.connect(id);
            setupConnection();
        });
    });

    function setupConnection() {
        conn.on('data', (data) => {
            // Data Format: { type: 'pos', id: 'uuid', x, y, z, ry }
            if (data.type === 'pos') {
                updateRemotePlayer(data);
            }
        });
        document.getElementById('my-id').innerText = "Status: CONNECTED";
    }

    function updateNetwork() {
        if (conn && conn.open) {
            conn.send({
                type: 'pos',
                id: myPeerId || 'client',
                x: camera.position.x,
                y: camera.position.y - 4, // Model offset
                z: camera.position.z,
                ry: camera.rotation.y
            });
        }
    }

    function updateRemotePlayer(data) {
        if (!remotePlayers[data.id]) {
            // Spawn new player model
            let mesh;
            if (loadedAssets.player) {
                mesh = loadedAssets.player.clone();
                mesh.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);
            } else {
                mesh = new THREE.Mesh(new THREE.CapsuleGeometry(1, 4, 4), new THREE.MeshBasicMaterial({color: 0x00ff00}));
            }
            scene.add(mesh);
            remotePlayers[data.id] = mesh;
        }
        const p = remotePlayers[data.id];
        p.position.set(data.x, data.y, data.z);
        p.rotation.y = data.ry + Math.PI; // Adjust GLTF rotation
    }

    // 6. LEVEL GENERATION
    function resetLevel() {
        worldObjects.clear();
        scraps = []; enemies = []; mines = []; bonusScraps = []; energyDrinkObject = null;
        player.inventory = []; player.weight = 0; player.hasEnergyDrink = false;
        
        createEffects();

        const mapW = GAME_CONFIG.mapSize * GAME_CONFIG.tileSize;
        const floor = new THREE.Mesh(new THREE.PlaneGeometry(mapW, mapW), matFloor);
        floor.rotation.x = -Math.PI / 2; floor.name = "FLOOR"; worldObjects.add(floor);

        const shipX = Math.floor(GAME_CONFIG.mapSize/2), shipZ = Math.floor(GAME_CONFIG.mapSize/2), range = 3; 
        const shipFloor = new THREE.Mesh(new THREE.PlaneGeometry(range*2*GAME_CONFIG.tileSize, range*2*GAME_CONFIG.tileSize), matShip);
        shipFloor.rotation.x = -Math.PI/2; shipFloor.position.set(0,0.1,0); worldObjects.add(shipFloor);
        shipZone.setFromObject(shipFloor); shipZone.max.y = 15;

        const boxGeo = new THREE.BoxGeometry(GAME_CONFIG.tileSize, GAME_CONFIG.wallHeight, GAME_CONFIG.tileSize);
        for (let x=0; x < GAME_CONFIG.mapSize; x++) for (let z=0; z < GAME_CONFIG.mapSize; z++) {
            let isWall = (x === 0 || x === GAME_CONFIG.mapSize-1 || z === 0 || z === GAME_CONFIG.mapSize-1 || Math.random() < 0.12);
            if (x > shipX-range && x < shipX+range && z > shipZ-range && z < shipZ+range) isWall = false;
            if (isWall) {
                const wall = new THREE.Mesh(boxGeo, matWall);
                wall.position.set((x-GAME_CONFIG.mapSize/2)*GAME_CONFIG.tileSize, GAME_CONFIG.wallHeight/2, (z-GAME_CONFIG.mapSize/2)*GAME_CONFIG.tileSize);
                worldObjects.add(wall); walls.push(new THREE.Box3().setFromObject(wall));
            }
        }
        
        leverMesh = new THREE.Mesh(new THREE.BoxGeometry(2,4,2), matLever);
        leverMesh.position.set((shipX-range+1-GAME_CONFIG.mapSize/2)*GAME_CONFIG.tileSize, 2, (shipZ-GAME_CONFIG.mapSize/2)*GAME_CONFIG.tileSize);
        leverMesh.userData = { type: 'lever' }; worldObjects.add(leverMesh);

        spawnGroup(20, 'scrap');
        spawnGroup(2 + Math.floor(gameState.days*0.5), 'enemy');
        spawnGroup(10, 'mine');
        spawnGroup(1, 'energy_drink');

        camera.position.set(0, 5, 0); camera.rotation.set(0,0,0);
    }
    
    function spawnGroup(count, type) {
        let spawned = 0;
        while(spawned < count) {
            let rx = (Math.random()*GAME_CONFIG.mapSize - GAME_CONFIG.mapSize/2)*GAME_CONFIG.tileSize;
            let rz = (Math.random()*GAME_CONFIG.mapSize - GAME_CONFIG.mapSize/2)*GAME_CONFIG.tileSize;
            if (Math.abs(rx) > 20 && Math.abs(rz) > 20) {
                if(type === 'scrap') spawnScrap({value: Math.floor(30+Math.random()*70), weight: Math.floor(5+Math.random()*15)}, new THREE.Vector3(rx, 1, rz));
                if(type === 'enemy') spawnEnemy(new THREE.Vector3(rx, 3, rz));
                if(type === 'mine') spawnMine(new THREE.Vector3(rx, 0.2, rz));
                if(type === 'energy_drink') spawnEnergyDrink(new THREE.Vector3(rx, 1.5, rz));
                spawned++;
            }
        }
    }

    function spawnScrap(data, pos, isBonus = false) {
        let mesh;
        let mIndex = Math.floor(Math.random() * loadedAssets.scraps.length);
        if(loadedAssets.scraps[mIndex]) mesh = loadedAssets.scraps[mIndex].clone();
        else mesh = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshStandardMaterial({map: scrapTexture}));
        mesh.scale.set(MODEL_SCALE, MODEL_SCALE, MODEL_SCALE);
        mesh.position.copy(pos); mesh.userData = { type: 'scrap', ...data };
        if (isBonus) { bonusScraps.push(mesh); } else { scraps.push(mesh); worldObjects.add(mesh); }
    }
    function spawnEnemy(pos) { let mesh; if(loadedAssets.enemy){mesh=loadedAssets.enemy.clone();mesh.scale.set(MODEL_SCALE,MODEL_SCALE,MODEL_SCALE);}else{mesh=new THREE.Mesh(new THREE.CylinderGeometry(2,2,6,8),new THREE.MeshStandardMaterial({color:0xaa0000}));} mesh.position.copy(pos);mesh.userData={speed:5+Math.random()*3};worldObjects.add(mesh);enemies.push(mesh); }
    function spawnMine(pos) { const g=new THREE.Group();const b=new THREE.Mesh(new THREE.CylinderGeometry(1.5,1.5,0.4,16),matMineBase);const l=new THREE.Mesh(new THREE.SphereGeometry(0.3,8,8),new THREE.MeshBasicMaterial({color:0xff0000}));l.position.y=0.3;g.add(b);g.add(l);g.position.copy(pos);g.userData={type:'mine',lightMesh:l,pulseTimer:Math.random()*10};worldObjects.add(g);mines.push(g); }
    function spawnEnergyDrink(pos) {
        let mesh;
        if (loadedAssets.energy) mesh = loadedAssets.energy.clone();
        else mesh = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1, 16), new THREE.MeshBasicMaterial({color: 0x0000ff})); 
        mesh.position.copy(pos); mesh.userData = { type: 'energy_drink' };
        energyDrinkObject = mesh; worldObjects.add(mesh);
    }
    
    // 7. INPUT
    document.getElementById('start-btn').addEventListener('click', () => {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        if(gameState.inMenu) {
            gameState.inMenu = false;
            document.getElementById('terminal').classList.add('hidden');
            document.getElementById('ui-layer').classList.remove('hidden');
            resetLevel();
            animate();
        }
        document.body.requestPointerLock();
    });
    
    document.addEventListener('pointerlockchange', () => { if (document.pointerLockElement !== document.body && !gameState.inMenu && !gameState.gameOver) document.getElementById('pause-overlay').style.display = 'flex'; else document.getElementById('pause-overlay').style.display = 'none'; });
    document.getElementById('pause-overlay').addEventListener('click', () => document.body.requestPointerLock());
    document.addEventListener('keydown', (e) => {
        if(e.code === 'KeyW') moveF=true; if(e.code === 'KeyS') moveB=true; if(e.code === 'KeyA') moveL=true; if(e.code === 'KeyD') moveR=true;
        if(e.code === 'ShiftLeft') sprint=true; if(e.code === 'KeyE') interact(); if(e.code === 'KeyG') dropItem();
        if(e.code === 'KeyF') useEnergyDrink();
    });
    document.addEventListener('keyup', (e) => { if(e.code === 'KeyW') moveF=false; if(e.code === 'KeyS') moveB=false; if(e.code === 'KeyA') moveL=false; if(e.code === 'KeyD') moveR=false; if(e.code === 'ShiftLeft') sprint=false; });
    document.addEventListener('mousemove', (e) => { if(document.pointerLockElement===document.body && !gameState.gameOver) { camera.rotation.y-=e.movementX*0.002; camera.rotation.x-=e.movementY*0.002; camera.rotation.x=Math.max(-Math.PI/2,Math.min(Math.PI/2,camera.rotation.x)); }});
    document.addEventListener('mousedown', (e) => { if(e.button === 2) scan(); });

    function interact() {
        if(gameState.inMenu) return;
        raycaster.setFromCamera(center, camera);
        
        // INTERACTION FIX: Check both normal objects OR bonus scraps depending on state
        let objectsToCheck = worldObjects.children;
        if (energyEffect.active && energyEffect.bonusWorldTimer > 0) {
            objectsToCheck = bonusScraps; // Only check bonus items in trip
        }

        const intersects = raycaster.intersectObjects(objectsToCheck, true);
        for (let i = 0; i < intersects.length; i++) {
            if (intersects[i].distance > 15) break;
            let obj = intersects[i].object;
            // Traverse up to find user data
            while(obj.parent && obj.parent !== worldObjects && obj.parent !== scene && !obj.userData.type) { obj = obj.parent; }

            if (obj.userData.type === 'scrap') {
                if (player.inventory.length >= player.maxSlots) { notify("INVENTORY FULL", true); return; }
                player.inventory.push(obj.userData); player.weight += obj.userData.weight;
                
                if (energyEffect.active) {
                    scene.remove(obj); // Remove from scene (bonus item)
                    bonusScraps = bonusScraps.filter(s => s !== obj);
                } else {
                    obj.parent.remove(obj); // Remove from worldObjects
                    scraps = scraps.filter(s => s !== obj);
                }
                updateHUD(); return;
            } 
            else if (obj.userData.type === 'energy_drink') {
                if (player.hasEnergyDrink) { notify("ALREADY HOLDING ONE", true); return; }
                player.hasEnergyDrink = true;
                worldObjects.remove(obj); energyDrinkObject = null;
                updateHUD(); return;
            }
            else if (obj.userData.type === 'lever') { endDay(false); return; }
        }
    }
    
    // 8. ENERGY DRINK
    function useEnergyDrink() {
        if (!player.hasEnergyDrink || energyEffect.active) return;
        energyEffect.active = true; player.hasEnergyDrink = false; updateHUD();

        if (energyMusicBuffer) {
            energyEffect.music = new THREE.Audio(listener);
            energyEffect.music.setBuffer(energyMusicBuffer);
            energyEffect.music.setLoop(false);
            energyEffect.music.setVolume(0.5);
            energyEffect.music.play();
        }

        document.getElementById('energy-overlay').style.display = 'block';
        setTimeout(() => { if(energyEffect.active) scene.background = warpBgTexture; }, 40000);
        setTimeout(() => { if(energyEffect.active) enterBonusWorld(); }, 45000);
    }

    function enterBonusWorld() {
        document.getElementById('energy-overlay').style.display = 'none';
        scene.background = bonusBgTexture;
        worldObjects.visible = false; 
        
        // Hide remote players in trip (optional, but cleaner)
        Object.values(remotePlayers).forEach(p => p.visible = false);

        let floor = scene.getObjectByName("FLOOR"); if(floor) floor.material = matBonusFloor;

        for (let i = 0; i < 20; i++) {
            const angle = Math.random() * Math.PI * 2;
            const dist = 5 + Math.random() * 20;
            const pos = new THREE.Vector3(Math.cos(angle) * dist, 1, Math.sin(angle) * dist).add(camera.position);
            spawnScrap({ name: "Hyperian Crystal", value: 150 + Math.floor(Math.random()*100), weight: 2.5 }, pos, true);
        }
        bonusScraps.forEach(s => scene.add(s)); // Add directly to scene
        energyEffect.bonusWorldTimer = 60;
        document.getElementById('bonus-timer').style.display = 'block';
    }

    function exitBonusWorld() {
        energyEffect.active = false;
        if (energyEffect.music && energyEffect.music.isPlaying) energyEffect.music.stop();

        document.getElementById('energy-overlay').style.display = 'none';
        document.getElementById('bonus-timer').style.display = 'none';
        
        // Show remote players again
        Object.values(remotePlayers).forEach(p => p.visible = true);

        scene.background = defaultBgColor;
        worldObjects.visible = true; 
        let floor = scene.getObjectByName("FLOOR"); if(floor) floor.material = matFloor;
        bonusScraps.forEach(s => scene.remove(s)); bonusScraps = [];
        
        camera.position.set(0, 5, 0); player.velocity.set(0,0,0);
        notify("The trip is over.", false);
    }
    
    // 9. GAME LOOP
    const clock = new THREE.Clock();
    let networkTimer = 0;

    function update() {
        if (gameState.inMenu || gameState.gameOver) return;
        const delta = clock.getDelta();
        if (document.pointerLockElement !== document.body) return;

        updateEffects(delta);
        updateNetwork();

        gameState.time += delta * 15;
        document.getElementById('hud-time').innerText = `${Math.floor(gameState.time/60).toString().padStart(2,'0')}:${Math.floor(gameState.time%60).toString().padStart(2,'0')}`;
        
        if (energyEffect.active && energyEffect.bonusWorldTimer > 0) {
            energyEffect.bonusWorldTimer -= delta;
            document.getElementById('bonus-timer').innerText = Math.ceil(energyEffect.bonusWorldTimer);
            if (energyEffect.bonusWorldTimer <= 0) exitBonusWorld();
        }

        let speed=sprint?player.runSpeed:player.speed; speed=Math.max(3,speed-(player.weight*0.15));
        if(sprint&&(moveF||moveB||moveL||moveR)){player.stamina-=delta*15;if(player.stamina<=0)sprint=false;}else if(player.stamina<100){player.stamina+=delta*10;}
        document.getElementById('hud-stamina').innerText=Math.floor(player.stamina);
        player.velocity.x-=player.velocity.x*10*delta;player.velocity.z-=player.velocity.z*10*delta;
        if(moveF||moveB||moveL||moveR){const d=new THREE.Vector3();camera.getWorldDirection(d);d.y=0;d.normalize();const s=new THREE.Vector3();s.crossVectors(camera.up,d).normalize();const v=new THREE.Vector3();if(moveF)v.add(d);if(moveB)v.sub(d);if(moveR)v.sub(s);if(moveL)v.add(s);v.normalize();player.velocity.x+=v.x*speed*delta*80;player.velocity.z+=v.z*speed*delta*80;}
        let nx=camera.position.x+player.velocity.x*delta,nz=camera.position.z+player.velocity.z*delta;
        if(!checkCol(nx,camera.position.z))camera.position.x=nx;
        if(!checkCol(camera.position.x,nz))camera.position.z=nz;

        raycaster.setFromCamera(center,camera);
        // Interaction UI Check
        let objectsToCheck = energyEffect.active ? bonusScraps : worldObjects.children;
        const intersects=raycaster.intersectObjects(objectsToCheck,true);
        const interactMsg=document.getElementById('interact-msg');interactMsg.style.display='none';
        for(let i=0;i<intersects.length;i++){if(intersects[i].distance>15)break;let obj=intersects[i].object;while(obj.parent&&obj.parent!==worldObjects&&obj.parent!==scene&&!obj.userData.type)obj=obj.parent;if(obj.userData.type==='scrap'){interactMsg.innerText=`[E] GRAB ${obj.userData.name||'SCRAP'}`;interactMsg.style.display='block';break;}else if(obj.userData.type==='energy_drink'){interactMsg.innerText=`[E] GRAB ENERGY DRINK`;interactMsg.style.display='block';break;}else if(obj.userData.type==='lever'){interactMsg.innerText=`[E] LAUNCH SHIP`;interactMsg.style.display='block';break;}}
        
        if (!energyEffect.active || energyEffect.bonusWorldTimer <= 0) {
            enemies.forEach(en=>{const dist=en.position.distanceTo(camera.position);if(shipZone.containsPoint(en.position)){const away=en.position.clone().normalize();en.position.add(away.multiplyScalar(en.userData.speed*delta));return;}if(dist<60){const dir=new THREE.Vector3().subVectors(camera.position,en.position).normalize();const mx=dir.x*en.userData.speed*delta,mz=dir.z*en.userData.speed*delta;if(!checkCol(en.position.x+mx,en.position.z))en.position.x+=mx;if(!checkCol(en.position.x,en.position.z+mz))en.position.z+=mz;en.lookAt(camera.position.x,en.position.y,camera.position.z);if(dist<3)killPlayer("KILLED BY ENTITY");}});
            mines.forEach(m=>{m.userData.pulseTimer+=delta*3;const intense=(Math.sin(m.userData.pulseTimer)+1)/2;m.userData.lightMesh.material.color.setHSL(0,1,0.3+intense*0.7);const dx=camera.position.x-m.position.x;const dz=camera.position.z-m.position.z;const dist=Math.sqrt(dx*dx+dz*dz);if(dist<1.6&&Math.abs(camera.position.y-m.position.y)<5){killPlayer("BLOWN UP");}});
        }
    }
    
    function checkCol(x,z){const box=new THREE.Box3().setFromCenterAndSize(new THREE.Vector3(x,4,z),new THREE.Vector3(2,8,2));return walls.some(w=>box.intersectsBox(w));}
    function dropItem(){if(player.inventory.length===0)return;const item=player.inventory.pop();player.weight-=item.weight;const dropPos=new THREE.Vector3();camera.getWorldDirection(dropPos);dropPos.multiplyScalar(5).add(camera.position);dropPos.y=1;spawnScrap(item,dropPos);updateHUD();}
    function scan(){const mat=new THREE.LineBasicMaterial({color:0x00ffff,transparent:true,opacity:0.2,depthTest:false});const matDanger=new THREE.LineBasicMaterial({color:0xff0000,transparent:true,opacity:0.8,depthTest:false});let list=[...scraps,...enemies,...mines,...bonusScraps];if(leverMesh)list.push(leverMesh);if(energyDrinkObject)list.push(energyDrinkObject);list.forEach(obj=>{if(obj.position.distanceTo(camera.position)<100){const box=new THREE.Box3().setFromObject(obj);const size=new THREE.Vector3();box.getSize(size);const geo=new THREE.BoxGeometry(size.x,size.y,size.z);const isDanger=(obj.userData.type==='mine'||enemies.includes(obj));const wire=new THREE.LineSegments(new THREE.EdgesGeometry(geo),isDanger?matDanger:mat);const c=new THREE.Vector3();box.getCenter(c);wire.position.copy(c);scene.add(wire);setTimeout(()=>{scene.remove(wire);geo.dispose();},2000);}});}
    function killPlayer(reason){if(gameState.gameOver)return;gameState.gameOver=true;if(energyEffect.active)exitBonusWorld();notify(`CRITICAL INJURY: ${reason||"UNKNOWN"}`,true);document.exitPointerLock();setTimeout(()=>{player.inventory=[];endDay(true);},3000);}
    function endDay(died){if(energyEffect.active)exitBonusWorld();gameState.days--;document.exitPointerLock();if(gameState.days<=0){if(gameState.money>=gameState.quota){gameState.quota+=200+Math.floor(Math.random()*100);gameState.days=3;alert(`CONTRACT RENEWED.\n\nNEW QUOTA: ${gameState.quota}`);}else{alert(`QUOTA FAILED (${gameState.money}/${gameState.quota}).\n\nFIRED.`);location.reload();return;}}gameState.inMenu=true;gameState.gameOver=false;document.getElementById('ui-layer').classList.add('hidden');document.getElementById('terminal').classList.remove('hidden');document.getElementById('menu-money').innerText=gameState.money;document.getElementById('menu-quota').innerText=gameState.quota;document.getElementById('menu-days').innerText=gameState.days;}
    function updateHUD(){document.getElementById('hud-money').innerText=gameState.money;document.getElementById('hud-quota').innerText=gameState.quota;document.getElementById('hud-weight').innerText=player.weight;let invHTML=player.inventory.length>0?player.inventory.map(i=>`[${i.name||'SCRAP'}]`).join('<br>'):"EMPTY HANDS";if(player.hasEnergyDrink)invHTML+='<br><span style="color:#00ffff;">[MONSTER ENERGY]</span>';document.getElementById('hud-inventory').innerHTML=invHTML;}
    function notify(text,isBad){const n=document.getElementById('notification');n.innerText=text;n.className=isBad?'red-text':'';n.style.display='block';setTimeout(()=>n.style.display='none',3000);}
    
    function animate(){requestAnimationFrame(animate);update();renderer.render(scene,camera);}
</script>
</body>
</html>