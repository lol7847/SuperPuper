<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mafia Protocol</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #121212;
            --surface: #1e1e1e;
            --primary: #00bcd4; /* Cyan */
            --danger: #ef5350;   /* Red */
            --success: #66bb6a;  /* Green */
            --text: #ffffff;
        }

        body {
            margin: 0;
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Segoe UI', Roboto, Helvetica, sans-serif;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            height: 100vh;
            user-select: none;
        }

        /* --- UTILS --- */
        .hidden { display: none !important; }
        h1, h2 { font-weight: 300; letter-spacing: 2px; text-transform: uppercase; margin: 0; }
        
        button {
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
            padding: 12px 25px;
            font-size: 1rem;
            text-transform: uppercase;
            border-radius: 4px;
            cursor: pointer;
            transition: 0.2s;
        }
        button:active { background: var(--primary); color: #000; }
        button:disabled { border-color: #555; color: #555; pointer-events: none; }
        
        input {
            background: #222; border: 1px solid #444; color: white;
            padding: 10px; font-size: 1.1rem; text-align: center;
            width: 70%; margin: 10px 0; border-radius: 4px; outline: none;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: var(--bg); z-index: 10;
        }

        /* --- GAME UI --- */
        .header {
            position: absolute; top: 0; width: 100%;
            padding: 15px; text-align: center;
            background: rgba(0,0,0,0.5);
            border-bottom: 1px solid #333;
            z-index: 5;
        }
        .header .status { color: var(--primary); font-size: 1.2rem; margin-bottom: 5px; }
        .header .timer { font-size: 1.5rem; font-weight: bold; }
        .header .my-role { font-size: 0.9rem; color: #888; margin-top: 5px; }

        /* CENTER TABLE */
        .game-area {
            position: relative;
            flex-grow: 1;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Players in a circle */
        .player-node {
            position: absolute;
            width: 70px; height: 90px;
            display: flex; flex-direction: column; align-items: center;
            transform: translate(-50%, -50%);
            transition: 0.3s;
            cursor: pointer;
        }
        .avatar {
            width: 60px; height: 60px;
            border-radius: 50%;
            background: #333;
            border: 2px solid #555;
            display: flex; align-items: center; justify-content: center;
            font-size: 1.5rem; font-weight: bold; color: #aaa;
        }
        .name-tag {
            margin-top: 5px; font-size: 0.8rem;
            background: rgba(0,0,0,0.7); padding: 2px 6px; border-radius: 4px;
        }

        /* States */
        .player-node.selected .avatar { border-color: var(--primary); background: #004d40; box-shadow: 0 0 15px var(--primary); }
        .player-node.dead .avatar { border-color: var(--danger); opacity: 0.5; color: var(--danger); }
        .player-node.dead .name-tag { text-decoration: line-through; }

        /* SHERIFF LIST (Bottom Left) */
        .intel-panel {
            position: absolute; bottom: 20px; left: 20px;
            width: 160px;
            background: rgba(0, 0, 0, 0.8);
            border-left: 3px solid var(--primary);
            padding: 10px;
            font-size: 0.9rem;
            z-index: 20;
            display: none; /* Hidden by default */
        }
        .intel-row { display: flex; justify-content: space-between; margin-bottom: 5px; border-bottom: 1px solid #333; padding-bottom: 2px; }
        .val-unknown { color: #777; }
        .val-mafia { color: var(--danger); font-weight: bold; }
        .val-innocent { color: var(--success); }

        /* ACTION BUTTON (Bottom Center) */
        .action-container {
            position: absolute; bottom: 30px; left: 50%;
            transform: translateX(-50%);
            z-index: 30;
        }
        #confirm-btn {
            background: var(--primary); color: #000; border: none; font-weight: bold;
            padding: 15px 40px; border-radius: 30px; box-shadow: 0 4px 10px rgba(0,188,212,0.3);
            display: none;
        }
        #confirm-btn:active { transform: translateX(-50%) scale(0.95); }

        /* NOTIFICATION */
        .toast {
            position: absolute; top: 40%; width: 100%; text-align: center;
            font-size: 1.5rem; color: var(--primary);
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
            opacity: 0; pointer-events: none; transition: 0.5s; z-index: 50;
        }

    </style>
</head>
<body>

    <!-- LOGIN SCREEN -->
    <div id="screen-menu" class="screen">
        <h1 style="color:var(--primary); margin-bottom: 20px;">MAFIA ONLINE</h1>
        <input type="text" id="username" placeholder="Enter Name" maxlength="10">
        <div style="margin-top: 20px;">
            <button onclick="hostGame()">Host Game</button>
        </div>
        <div style="margin-top: 10px; display:flex; gap:10px; align-items:center;">
            <input type="text" id="join-id" placeholder="Room ID" style="width: 120px; margin:0;">
            <button onclick="joinGame()">Join</button>
        </div>
        <p id="status-msg" style="color: #777; font-size: 0.9rem; margin-top: 15px;"></p>
    </div>

    <!-- LOBBY SCREEN -->
    <div id="screen-lobby" class="screen hidden">
        <h2>LOBBY</h2>
        <div style="background:#222; padding:10px 20px; border-radius:4px; margin: 20px 0; font-family: monospace; color: var(--primary); cursor: pointer;" onclick="copyId()">
            ID: <span id="lobby-id">...</span> (Tap to Copy)
        </div>
        <div id="lobby-list" style="display:flex; flex-wrap:wrap; justify-content:center; gap:10px; max-width: 400px;"></div>
        <button id="start-btn" onclick="startGame()" style="margin-top: 30px;" disabled>Start Game</button>
        <p style="color:#555; font-size: 0.8rem; margin-top: 10px;">Requires 4+ players</p>
    </div>

    <!-- GAME SCREEN -->
    <div id="screen-game" class="screen hidden">
        
        <!-- HEADER -->
        <div class="header">
            <div id="phase-text" class="status">WAITING...</div>
            <div id="timer-text" class="timer">00</div>
            <div id="my-role" class="my-role">Role: ...</div>
        </div>

        <!-- NOTIFICATION OVERLAY -->
        <div id="toast" class="toast">ALERT MESSAGE</div>

        <!-- CENTER TABLE -->
        <div id="game-area" class="game-area">
            <!-- Players generated here -->
        </div>

        <!-- SHERIFF LIST -->
        <div id="intel-panel" class="intel-panel">
            <div style="color:var(--primary); font-size:0.8rem; margin-bottom:8px;">SUSPECT LIST</div>
            <div id="intel-list-content">
                <!-- Javascript fills this: "Obama - ?" -->
            </div>
        </div>

        <!-- ACTION BUTTON -->
        <div class="action-container">
            <button id="confirm-btn" onclick="confirmAction()">CONFIRM TARGET</button>
        </div>

    </div>

    <script>
        // --- CONFIG ---
        const ROLES = ['Mafia', 'Doctor', 'Detective', 'Villager', 'Villager', 'Mafia', 'Villager', 'Villager'];
        const TIMERS = {
            MAFIA: 20,
            SHERIFF: 20,
            MEDIC: 20,
            DAY: 40
        };

        // --- GLOBAL VARIABLES ---
        let peer, conn;
        let myId, myName;
        let isHost = false;
        let connections = [];
        let myRole = null;

        // Game State
        let players = []; 
        let intelMemory = {}; // { playerId: "Status" } for Sheriff
        let gameState = {
            phase: 'lobby', // mafia, sheriff, medic, day
            timer: 0,
            actions: {} // { mafia: id, doctor: id... }
        };
        
        let selectedTarget = null;
        let gameInterval = null;

        // --- PEERJS CONNECTION ---
        function initPeer(cb) {
            document.getElementById('status-msg').innerText = "Connecting...";
            peer = new Peer();
            peer.on('open', (id) => {
                myId = id;
                document.getElementById('status-msg').innerText = "";
                cb(id);
            });
            peer.on('error', err => alert("Connection Error: " + err.type));
        }

        // --- HOST LOGIC ---
        function hostGame() {
            myName = document.getElementById('username').value.trim() || "Host";
            isHost = true;
            initPeer((id) => {
                showScreen('screen-lobby');
                document.getElementById('lobby-id').innerText = id;
                players.push({ id: myId, name: myName, role: null, isAlive: true });
                updateLobby();

                peer.on('connection', (c) => {
                    connections.push(c);
                    c.on('data', data => handleHostData(data, c.peer));
                    c.on('close', () => {
                        players = players.filter(p => p.id !== c.peer);
                        connections = connections.filter(x => x.peer !== c.peer);
                        updateLobby();
                        broadcastState();
                    });
                });
            });
        }

        function handleHostData(data, senderId) {
            if(data.type === 'join') {
                players.push({ id: senderId, name: data.name, role: null, isAlive: true });
                updateLobby();
                broadcastState();
            } else if (data.type === 'action') {
                handleAction(senderId, data.targetId);
            }
        }

        function updateLobby() {
            const list = document.getElementById('lobby-list');
            list.innerHTML = players.map(p => `<div style="background:#333; padding:5px 10px; border-radius:4px;">${p.name}</div>`).join('');
            document.getElementById('start-btn').disabled = players.length < 4;
        }

        function startGame() {
            if(players.length < 4) return;
            // Assign roles
            let deck = ROLES.slice(0, players.length).sort(() => Math.random() - 0.5);
            players.forEach((p, i) => p.role = deck[i]);
            
            showScreen('screen-game');
            runPhase('mafia');
        }

        // --- GAME LOOP ---
        function runPhase(phase) {
            gameState.phase = phase;
            let duration = 10;
            let title = "";

            if(phase === 'mafia') { 
                duration = TIMERS.MAFIA; title = "Night: Mafia Turn"; 
                gameState.actions = { votes: {} }; // Reset night actions
            }
            else if(phase === 'sheriff') { duration = TIMERS.SHERIFF; title = "Night: Sheriff Turn"; }
            else if(phase === 'medic') { duration = TIMERS.MEDIC; title = "Night: Medic Turn"; }
            else if(phase === 'day') { duration = TIMERS.DAY; title = "Day: Discuss & Vote"; }

            gameState.timer = duration;
            broadcastState(title);

            if(gameInterval) clearInterval(gameInterval);
            gameInterval = setInterval(() => {
                gameState.timer--;
                if(gameState.timer <= 0) {
                    clearInterval(gameInterval);
                    nextPhase();
                } else if(gameState.timer % 5 === 0) {
                    broadcastTimer();
                }
            }, 1000);
        }

        function nextPhase() {
            const p = gameState.phase;
            if(p === 'mafia') runPhase('sheriff');
            else if(p === 'sheriff') runPhase('medic');
            else if(p === 'medic') resolveNight();
            else if(p === 'day') resolveDay();
        }

        function handleAction(actorId, targetId) {
            const actor = players.find(p => p.id === actorId);
            if(!actor.isAlive) return;

            if(gameState.phase === 'mafia' && actor.role === 'Mafia') {
                gameState.actions.mafia = targetId;
            }
            if(gameState.phase === 'sheriff' && actor.role === 'Detective') {
                const target = players.find(p => p.id === targetId);
                const result = target.role === 'Mafia' ? 'Mafia' : 'Innocent';
                sendPrivate(actorId, { type: 'intel', targetId: targetId, result: result });
            }
            if(gameState.phase === 'medic' && actor.role === 'Doctor') {
                gameState.actions.medic = targetId;
            }
            if(gameState.phase === 'day') {
                gameState.actions.votes[actorId] = targetId;
            }
        }

        function resolveNight() {
            let msg = "Sunrise. ";
            const kill = gameState.actions.mafia;
            const heal = gameState.actions.medic;

            if(kill) {
                if(kill === heal) msg += "The Doctor saved the victim!";
                else {
                    const vic = players.find(p => p.id === kill);
                    if(vic) { vic.isAlive = false; msg += `${vic.name} was killed.`; }
                }
            } else {
                msg += "No one died.";
            }

            if(checkWin()) return;
            showToastHost(msg);
            setTimeout(() => runPhase('day'), 3000);
        }

        function resolveDay() {
            const votes = gameState.actions.votes;
            let counts = {};
            Object.values(votes).forEach(v => counts[v] = (counts[v]||0)+1);
            
            let max = 0, victimId = null;
            for(let id in counts) { if(counts[id]>max){ max=counts[id]; victimId=id; }}

            let msg = "No one voted out.";
            if(victimId && max > 1) {
                const v = players.find(p => p.id === victimId);
                v.isAlive = false;
                msg = `${v.name} was voted out.`;
            }

            if(checkWin()) return;
            showToastHost(msg);
            setTimeout(() => runPhase('mafia'), 3000);
        }

        function checkWin() {
            const m = players.filter(p => p.role === 'Mafia' && p.isAlive).length;
            const v = players.filter(p => p.role !== 'Mafia' && p.isAlive).length;
            if(m === 0) { endGame("Villagers Win!"); return true; }
            if(m >= v) { endGame("Mafia Wins!"); return true; }
            return false;
        }

        function endGame(msg) {
            broadcastState(msg);
            showToastHost(msg);
            if(gameInterval) clearInterval(gameInterval);
        }

        // --- NETWORKING UTILS ---
        function broadcastState(status) {
            const payload = {
                type: 'state',
                players: players.map(p => ({id:p.id, name:p.name, isAlive:p.isAlive})),
                phase: gameState.phase,
                timer: gameState.timer,
                status: status
            };
            // Local update
            updateGameUI(payload, players.find(p=>p.id===myId).role);
            // Remote update
            connections.forEach(c => {
                const p = players.find(x => x.id === c.peer);
                c.send({...payload, myRole: p ? p.role : 'Spectator'});
            });
        }

        function broadcastTimer() {
            const t = gameState.timer;
            document.getElementById('timer-text').innerText = t;
            connections.forEach(c => c.send({type:'timer', time:t}));
        }

        function sendPrivate(targetId, data) {
            if(targetId === myId) handlePrivate(data);
            else {
                const c = connections.find(x => x.peer === targetId);
                if(c) c.send(data);
            }
        }
        
        function showToastHost(msg) {
            showToast(msg);
            connections.forEach(c => c.send({type:'toast', msg:msg}));
        }

        // --- CLIENT LOGIC ---
        function joinGame() {
            myName = document.getElementById('username').value.trim() || "Player";
            const hostId = document.getElementById('join-id').value.trim();
            if(!hostId) return;

            initPeer((id) => {
                conn = peer.connect(hostId);
                conn.on('open', () => {
                    conn.send({ type: 'join', name: myName });
                });
                conn.on('data', handleClientData);
            });
        }

        function handleClientData(data) {
            if(data.type === 'state') {
                showScreen('screen-game');
                updateGameUI(data, data.myRole);
            }
            if(data.type === 'timer') document.getElementById('timer-text').innerText = data.time;
            if(data.type === 'intel') handleIntel(data);
            if(data.type === 'toast') showToast(data.msg);
        }

        function handlePrivate(data) {
            if(data.type === 'intel') handleIntel(data);
        }

        function handleIntel(data) {
            // Update local memory
            intelMemory[data.targetId] = data.result;
            // Force re-render of list
            renderIntel();
        }

        // --- RENDERER ---
        function updateGameUI(state, role) {
            myRole = role;
            document.getElementById('phase-text').innerText = state.status || state.phase.toUpperCase();
            document.getElementById('timer-text').innerText = state.timer;
            document.getElementById('my-role').innerText = "Role: " + role;

            // Render Circle
            const area = document.getElementById('game-area');
            area.innerHTML = '';
            
            const total = state.players.length;
            const radius = 130; // px
            
            // Build Intel Memory default if empty (only if we have players)
            if(Object.keys(intelMemory).length === 0 && total > 0) {
                state.players.forEach(p => { if(!intelMemory[p.id]) intelMemory[p.id] = "?"; });
            }

            state.players.forEach((p, i) => {
                const angle = (i / total) * 2 * Math.PI - (Math.PI/2);
                const x = Math.cos(angle) * radius;
                const y = Math.sin(angle) * radius;
                
                const div = document.createElement('div');
                div.className = `player-node ${p.isAlive ? '' : 'dead'} ${selectedTarget === p.id ? 'selected' : ''}`;
                div.style.left = `calc(50% + ${x}px)`;
                div.style.top = `calc(50% + ${y}px)`;
                div.onclick = () => selectPlayer(p.id, p.isAlive, state.phase);
                
                div.innerHTML = `
                    <div class="avatar">${p.name[0]}</div>
                    <div class="name-tag">${p.name}</div>
                `;
                area.appendChild(div);
            });

            // Handle Intel Panel Visibility
            const intelPanel = document.getElementById('intel-panel');
            if(role === 'Detective') {
                intelPanel.style.display = 'block';
                renderIntel(state.players);
            } else {
                intelPanel.style.display = 'none';
            }

            // Handle Button
            const btn = document.getElementById('confirm-btn');
            const amAlive = state.players.find(p => p.id === myId)?.isAlive;
            
            let myTurn = false;
            if(amAlive) {
                if(state.phase === 'mafia' && role === 'Mafia') myTurn = true;
                if(state.phase === 'sheriff' && role === 'Detective') myTurn = true;
                if(state.phase === 'medic' && role === 'Doctor') myTurn = true;
                if(state.phase === 'day') myTurn = true;
            }

            if(myTurn) {
                btn.style.display = 'block';
                btn.innerText = (state.phase === 'day') ? "VOTE" : (state.phase === 'sheriff' ? "INVESTIGATE" : "CONFIRM");
            } else {
                btn.style.display = 'none';
                selectedTarget = null;
            }
        }

        function renderIntel(playersList) {
            // If passed list use it, otherwise iterate keys (but keys don't have names)
            // Best to rely on the playersList from the last state update if possible, 
            // but for simplicity we assume playersList is available via global if not passed
            const list = document.getElementById('intel-list-content');
            list.innerHTML = '';
            
            for(let id in intelMemory) {
                if(id === myId) continue;
                // Find name
                // Note: In client, we might not have full player object if joined late, 
                // but usually handled by state.
                // We need to look up name from state.
                // Simplification: We iterate the UI nodes? No.
                // We use global players var which is synced.
                const p = players.find(x => x.id === id);
                if(!p) continue;

                const status = intelMemory[id];
                const cls = status === 'Mafia' ? 'val-mafia' : (status === 'Innocent' ? 'val-innocent' : 'val-unknown');
                
                const row = document.createElement('div');
                row.className = 'intel-row';
                row.innerHTML = `<span>${p.name}</span> <span class="${cls}">${status}</span>`;
                list.appendChild(row);
            }
        }

        function selectPlayer(id, isAlive, phase) {
            if(!isAlive) return;
            selectedTarget = id;
            
            // Visual update
            document.querySelectorAll('.player-node').forEach(el => el.classList.remove('selected'));
            // Find current clicked and add class - need index?
            // Re-rendering whole UI is safer to keep state consistent
            // Update internal state only and trigger simple re-render of classes
            // Quick hack for responsiveness:
            // Since we rebuild the DOM in updateGameUI, we rely on selectedTarget variable there.
            // But we need to redraw.
             // Re-calling updateGameUI with current state is tricky without the object.
             // Just manually update DOM classes for now:
             const nodes = document.getElementById('game-area').children;
             Array.from(nodes).forEach(n => {
                 if(n.innerHTML.includes(players.find(p=>p.id===id).name)) n.classList.add('selected');
                 else n.classList.remove('selected');
             });
        }

        function confirmAction() {
            if(!selectedTarget) return showToast("Select a player first!");
            
            if(isHost) handleAction(myId, selectedTarget);
            else conn.send({ type: 'action', targetId: selectedTarget });
            
            document.getElementById('confirm-btn').style.display = 'none';
            showToast("Action Confirmed");
        }

        // --- HELPER ---
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
            document.getElementById(id).classList.remove('hidden');
        }

        function copyId() {
            const txt = document.getElementById('lobby-id').innerText;
            navigator.clipboard.writeText(txt);
            showToast("ID Copied");
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.opacity = 1;
            setTimeout(() => t.style.opacity = 0, 3000);
        }

    </script>
</body>
</html>
