<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PROTOCOL: MAFIA // SECTOR 7</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@400;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --neon-green: #00ff9d;
            --neon-gold: #ffcc00;
            --bg-dark: #050510;
        }

        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            margin: 0; overflow: hidden;
            background: radial-gradient(circle at center, #1a1a2e 0%, #000000 100%);
            font-family: 'Rajdhani', sans-serif;
            color: var(--neon-blue);
            height: 100vh; display: flex; flex-direction: column;
        }

        .hidden { display: none !important; }
        h1, h2 { font-family: 'Orbitron', sans-serif; text-transform: uppercase; margin: 0; letter-spacing: 2px; }

        /* --- BUTTONS & INPUTS --- */
        button {
            background: rgba(0, 243, 255, 0.1); border: 1px solid var(--neon-blue);
            color: var(--neon-blue); padding: 12px 24px; font-family: 'Orbitron';
            cursor: pointer; transition: 0.3s; 
            clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
        }
        button:active { transform: scale(0.95); background: var(--neon-blue); color: black; }
        button:disabled { border-color: #333; color: #555; pointer-events: none; }

        input {
            background: transparent; border: none; border-bottom: 2px solid var(--neon-blue);
            color: #fff; font-family: 'Orbitron'; font-size: 1.2rem; text-align: center;
            width: 80%; margin: 10px 0; outline: none;
        }

        /* --- SCREENS --- */
        .screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            background: var(--bg-dark); z-index: 10; transition: opacity 0.5s;
        }

        /* --- GAME UI --- */
        .top-bar {
            position: absolute; top: 0; left: 0; width: 100%; padding: 15px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.9), transparent);
            z-index: 5; pointer-events: none;
        }
        .role-badge {
            border: 1px solid var(--neon-gold); color: var(--neon-gold);
            padding: 5px 15px; font-weight: bold; font-family: 'Orbitron';
            background: rgba(0,0,0,0.8); pointer-events: auto;
        }

        /* CENTER REACTOR */
        .table-container {
            position: absolute; top: 45%; left: 50%; /* Shifted up slightly */
            transform: translate(-50%, -50%);
            width: 280px; height: 280px;
            border-radius: 50%;
            border: 2px dashed var(--neon-blue);
            box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            animation: spin 60s linear infinite;
        }
        @keyframes spin { from { transform: translate(-50%, -50%) rotate(0deg); } to { transform: translate(-50%, -50%) rotate(360deg); } }

        .reactor-core {
            position: absolute; top: 45%; left: 50%;
            transform: translate(-50%, -50%);
            text-align: center; z-index: 4; width: 200px;
        }
        #timer-display { font-size: 3.5rem; color: #fff; text-shadow: 0 0 20px #fff; font-family: 'Orbitron'; }
        #phase-display { font-size: 1rem; color: var(--neon-green); letter-spacing: 2px; margin-top: 5px;}

        /* PLAYERS */
        .player-orbit { position: absolute; width: 100%; height: 100%; top: 0; left: 0; pointer-events: none; }
        .player-node {
            position: absolute; width: 80px; height: 80px; transform: translate(-50%, -50%);
            pointer-events: auto; cursor: pointer; display: flex; flex-direction: column; align-items: center;
            transition: 0.3s;
        }
        .node-circle {
            width: 60px; height: 60px; border-radius: 50%;
            background: #000; border: 2px solid #333;
            display: flex; align-items: center; justify-content: center;
            font-weight: bold; font-size: 1.5rem; color: #555;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .player-node.alive .node-circle { border-color: var(--neon-blue); color: #fff; box-shadow: 0 0 15px var(--neon-blue); }
        .player-node.dead .node-circle { border-color: var(--neon-red); color: var(--neon-red); opacity: 0.5; }
        .player-node.selected .node-circle { background: var(--neon-gold); color: #000; box-shadow: 0 0 25px var(--neon-gold); }
        .node-name { margin-top: 5px; font-size: 0.8rem; background: rgba(0,0,0,0.8); padding: 2px 5px; }

        /* SHERIFF INTEL PANEL (Left Bottom) */
        .intel-panel {
            position: absolute; bottom: 80px; left: 10px;
            width: 180px; background: rgba(0, 20, 0, 0.8);
            border: 1px solid var(--neon-green);
            padding: 10px; font-family: 'Orbitron'; font-size: 0.8rem;
            display: none; z-index: 20;
        }
        .intel-title { color: var(--neon-green); border-bottom: 1px solid var(--neon-green); margin-bottom: 5px; }
        .intel-row { display: flex; justify-content: space-between; margin-bottom: 3px; }
        .status-unknown { color: #555; }
        .status-mafia { color: var(--neon-red); }
        .status-innocent { color: var(--neon-blue); }

        /* CONFIRM BUTTON (Bottom Center) */
        #confirm-btn {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            width: 200px; height: 60px; font-size: 1.2rem; font-weight: bold;
            background: #000; border: 2px solid var(--neon-gold); color: var(--neon-gold);
            z-index: 30; display: none;
        }
        #confirm-btn:hover { background: var(--neon-gold); color: #000; }

        /* OVERLAYS */
        .overlay-msg {
            position: absolute; top: 20%; width: 100%; text-align: center;
            font-size: 1.5rem; color: var(--neon-red); text-shadow: 0 0 10px var(--neon-red);
            pointer-events: none; opacity: 0; transition: opacity 0.5s; z-index: 40;
        }
    </style>
</head>
<body>

    <!-- MAIN MENU -->
    <div id="screen-menu" class="screen">
        <h1 style="font-size: 2.5rem; color: var(--neon-blue);">MAFIA // SECTOR 7</h1>
        <br>
        <input type="text" id="username" placeholder="IDENTIFICATION" maxlength="12">
        <br>
        <button onclick="initHost()">INITIALIZE HOST</button>
        <div style="margin: 20px 0; display:flex; gap:10px;">
            <input type="text" id="join-id" placeholder="UPLINK ID" style="margin:0; width: 150px;">
            <button onclick="joinGame()">CONNECT</button>
        </div>
        <p id="menu-status" style="color: var(--neon-gold); font-size: 0.8rem;"></p>
    </div>

    <!-- LOBBY -->
    <div id="screen-lobby" class="screen hidden">
        <h2>PRE-FLIGHT CHECK</h2>
        <div style="background: #000; padding: 10px; border: 1px dashed var(--neon-blue); cursor: pointer;" onclick="copyId()">
            <span id="lobby-id" style="font-family: monospace;">GENERATING...</span>
        </div>
        <div id="lobby-list" style="margin: 30px 0; display: flex; gap: 10px; flex-wrap: wrap; justify-content: center;"></div>
        <button id="start-btn" onclick="startGame()" disabled>ENGAGE SEQUENCE</button>
        <p>WAITING FOR CREW (MIN 4)</p>
    </div>

    <!-- GAME UI -->
    <div id="screen-game" class="screen hidden">
        <div class="top-bar">
            <div><span id="day-counter">DAY 1</span></div>
            <div id="role-badge" class="role-badge">LOADING...</div>
        </div>

        <div class="overlay-msg" id="alert-overlay">SYSTEM ALERT</div>

        <div class="table-container"></div>
        <div class="reactor-core">
            <div id="timer-display">00</div>
            <div id="phase-display">STANDBY</div>
        </div>

        <div id="orbit-container" class="player-orbit"></div>

        <!-- SHERIFF INTEL LIST -->
        <div id="intel-panel" class="intel-panel">
            <div class="intel-title">SCAN RESULTS</div>
            <div id="intel-list"></div>
        </div>

        <!-- ACTION BUTTON -->
        <button id="confirm-btn" onclick="confirmAction()">ENGAGE</button>
    </div>

    <script>
        // --- CONFIG ---
        const ROLES_DECK = ['Mafia', 'Doctor', 'Detective', 'Villager', 'Villager', 'Mafia', 'Villager', 'Villager'];
        const TIMERS = {
            INTRO: 5,
            MAFIA: 15,
            DETECTIVE: 15,
            DOCTOR: 15,
            DAY: 45
        };

        // --- STATE ---
        let peer, conn;
        let myId, myName;
        let isHost = false;
        let connections = [];
        let myRole = "";
        
        let players = []; 
        let intelMap = {}; // Local Sheriff storage: { id: "Mafia" | "Innocent" | "?" }

        let gameState = {
            phase: 'lobby', // intro, mafia_turn, detective_turn, doctor_turn, day
            timer: 0,
            dayCount: 1,
            actions: {} // Temporary storage for the round
        };
        
        let selectedTarget = null;
        let hostInterval = null;

        // --- NETWORKING ---
        function initPeer(cb) {
            document.getElementById('menu-status').innerText = "ESTABLISHING UPLINK...";
            peer = new Peer();
            peer.on('open', (id) => {
                myId = id;
                document.getElementById('menu-status').innerText = "";
                cb(id);
            });
            peer.on('error', err => alert("ERROR: " + err.type));
        }

        // --- HOST LOGIC ---
        function initHost() {
            myName = document.getElementById('username').value.trim() || "COMMANDER";
            isHost = true;
            initPeer((id) => {
                document.getElementById('screen-menu').classList.add('hidden');
                document.getElementById('screen-lobby').classList.remove('hidden');
                document.getElementById('lobby-id').innerText = id;
                players.push({ id: myId, name: myName, role: null, isAlive: true, lastHealed: null });
                updateLobby();

                peer.on('connection', (c) => {
                    connections.push(c);
                    c.on('data', (data) => handleHostData(data, c.peer));
                    c.on('close', () => {
                        players = players.filter(p => p.id !== c.peer);
                        connections = connections.filter(x => x.peer !== c.peer);
                        updateLobby();
                        broadcastState();
                    });
                });
            });
        }

        function handleHostData(data, senderId) {
            if(data.type === 'join') {
                players.push({ id: senderId, name: data.name, role: null, isAlive: true, lastHealed: null });
                updateLobby();
                broadcastState();
            } else if (data.type === 'action') {
                processAction(senderId, data.targetId);
            }
        }

        function updateLobby() {
            document.getElementById('lobby-list').innerHTML = players.map(p => 
                `<div style="border:1px solid #0ff; padding:5px; font-size:0.8rem;">${p.name}</div>`
            ).join('');
            document.getElementById('start-btn').disabled = players.length < 4;
        }

        function startGame() {
            if(players.length < 4) return;
            // Assign roles
            let deck = ROLES_DECK.slice(0, players.length).sort(() => Math.random() - 0.5);
            players.forEach((p, i) => p.role = deck[i]);
            
            document.getElementById('screen-lobby').classList.add('hidden');
            document.getElementById('screen-game').classList.remove('hidden');
            
            gameState.dayCount = 1;
            runPhase('intro');
        }

        function runPhase(phase) {
            gameState.phase = phase;
            let duration = 5;
            let msg = "";

            // Phase Config
            switch(phase) {
                case 'intro': duration = TIMERS.INTRO; msg = "INITIALIZING..."; break;
                case 'mafia_turn': duration = TIMERS.MAFIA; msg = "MAFIA TARGETING"; break;
                case 'detective_turn': duration = TIMERS.DETECTIVE; msg = "DETECTIVE SCANNING"; break;
                case 'doctor_turn': duration = TIMERS.DOCTOR; msg = "MEDICAL ASSISTANCE"; break;
                case 'day': duration = TIMERS.DAY; msg = "DAY CYCLE: VOTE"; break;
            }

            // Clean up old actions if starting a new night sequence
            if(phase === 'mafia_turn') {
                gameState.actions = { votes: {} }; 
            }

            gameState.timer = duration;
            broadcastState(msg);

            if(hostInterval) clearInterval(hostInterval);
            hostInterval = setInterval(() => {
                gameState.timer--;
                if(gameState.timer <= 0) {
                    clearInterval(hostInterval);
                    nextPhase();
                } else if (gameState.timer % 5 === 0) {
                    broadcastTimer();
                }
            }, 1000);
        }

        function nextPhase() {
            const p = gameState.phase;
            if(p === 'intro') runPhase('mafia_turn');
            else if(p === 'mafia_turn') runPhase('detective_turn');
            else if(p === 'detective_turn') runPhase('doctor_turn');
            else if(p === 'doctor_turn') {
                resolveNightResults();
            }
            else if(p === 'day') resolveDayResults();
        }

        function processAction(actorId, targetId) {
            const actor = players.find(p => p.id === actorId);
            if(!actor || !actor.isAlive) return;

            const p = gameState.phase;
            
            if(p === 'mafia_turn' && actor.role === 'Mafia') {
                gameState.actions.mafia = targetId;
            }
            else if(p === 'detective_turn' && actor.role === 'Detective') {
                const target = players.find(p => p.id === targetId);
                const result = (target.role === 'Mafia') ? 'MAFIA' : 'INNOCENT';
                sendPrivate(actorId, { type: 'intel', targetId: targetId, status: result });
            }
            else if(p === 'doctor_turn' && actor.role === 'Doctor') {
                // Rule: Cannot heal same person twice in a row
                if(actor.lastHealed === targetId) {
                    sendPrivate(actorId, { type: 'alert', msg: "COOLDOWN: CANNOT HEAL SAME TARGET" });
                    return;
                }
                gameState.actions.doctor = targetId;
                actor.lastHealed = targetId;
            }
            else if(p === 'day') {
                gameState.actions.votes[actorId] = targetId;
            }
        }

        function resolveNightResults() {
            let msg = "SUNRISE. ";
            const killId = gameState.actions.mafia;
            const saveId = gameState.actions.doctor;

            if(killId) {
                if(killId === saveId) {
                    msg += "ATTACK BLOCKED BY MEDIC.";
                } else {
                    const victim = players.find(p => p.id === killId);
                    if(victim) {
                        victim.isAlive = false;
                        msg += `${victim.name} WAS ELIMINATED.`;
                    }
                }
            } else {
                msg += "NO CASUALTIES.";
            }

            if(checkWin()) return;
            
            // Show alert then start day
            broadcastAlert(msg);
            setTimeout(() => runPhase('day'), 3000);
        }

        function resolveDayResults() {
            // Tally Votes
            let counts = {};
            Object.values(gameState.actions.votes).forEach(t => counts[t] = (counts[t] || 0) + 1);
            
            let max = 0, victimId = null;
            for(let id in counts) {
                if(counts[id] > max) { max = counts[id]; victimId = id; }
            }

            let msg = "VOTE INCONCLUSIVE.";
            if(victimId && max > 1) {
                const v = players.find(p => p.id === victimId);
                v.isAlive = false;
                msg = `${v.name} WAS EJECTED.`;
            }

            if(checkWin()) return;

            broadcastAlert(msg);
            gameState.dayCount++;
            setTimeout(() => runPhase('mafia_turn'), 3000);
        }

        function checkWin() {
            const m = players.filter(p => p.isAlive && p.role === 'Mafia').length;
            const v = players.filter(p => p.isAlive && p.role !== 'Mafia').length;
            if(m === 0) { endGame("SECTOR SECURE: VILLAGERS WIN"); return true; }
            if(m >= v) { endGame("SECTOR LOST: MAFIA WINS"); return true; }
            return false;
        }

        function endGame(msg) {
            if(hostInterval) clearInterval(hostInterval);
            broadcastAlert(msg);
            broadcastState("GAME OVER");
        }

        function broadcastState(statusMsg) {
            const pubPlayers = players.map(p => ({ id: p.id, name: p.name, isAlive: p.isAlive }));
            const payload = {
                type: 'state',
                players: pubPlayers,
                phase: gameState.phase,
                timer: gameState.timer,
                day: gameState.dayCount,
                status: statusMsg
            };
            
            updateGameUI(payload, players.find(p => p.id === myId).role);
            
            connections.forEach(c => {
                const p = players.find(x => x.id === c.peer);
                c.send({ ...payload, myRole: p ? p.role : 'Spectator' });
            });
        }

        function broadcastAlert(msg) {
            showAlert(msg);
            connections.forEach(c => c.send({ type: 'alert', msg }));
        }

        function broadcastTimer() {
            const payload = { type: 'timer', time: gameState.timer };
            updateTimer(gameState.timer);
            connections.forEach(c => c.send(payload));
        }

        function sendPrivate(targetId, data) {
            if(targetId === myId) handlePrivateData(data);
            else {
                const c = connections.find(x => x.peer === targetId);
                if(c) c.send(data);
            }
        }

        // --- CLIENT LOGIC ---
        function joinGame() {
            myName = document.getElementById('username').value.trim() || "CADET";
            const hostId = document.getElementById('join-id').value.trim();
            if(!hostId) return;

            initPeer((id) => {
                conn = peer.connect(hostId);
                conn.on('open', () => {
                    document.getElementById('menu-status').innerText = "CONNECTED";
                    conn.send({ type: 'join', name: myName });
                });
                conn.on('data', data => {
                    if(data.type === 'state') {
                        if(document.getElementById('screen-game').classList.contains('hidden')) {
                            document.getElementById('screen-menu').classList.add('hidden');
                            document.getElementById('screen-game').classList.remove('hidden');
                        }
                        updateGameUI(data, data.myRole);
                    }
                    else if (data.type === 'timer') updateTimer(data.time);
                    else if (data.type === 'alert') showAlert(data.msg);
                    else if (data.type === 'intel') handleIntel(data);
                });
            });
        }

        function handlePrivateData(data) {
            if(data.type === 'intel') handleIntel(data);
            if(data.type === 'alert') showAlert(data.msg);
        }

        function handleIntel(data) {
            // Update local memory
            intelMap[data.targetId] = data.status;
            renderIntelList();
        }

        // --- UI RENDERER ---
        function updateGameUI(state, role) {
            myRole = role;
            document.getElementById('day-counter').innerText = `CYCLE ${state.day}`;
            document.getElementById('role-badge').innerText = role;
            document.getElementById('phase-display').innerText = state.phase.toUpperCase();
            updateTimer(state.timer);

            // Determine if it's my turn
            const amAlive = state.players.find(p => p.id === myId)?.isAlive;
            let myTurn = false;
            if(amAlive) {
                if(state.phase === 'mafia_turn' && role === 'Mafia') myTurn = true;
                if(state.phase === 'detective_turn' && role === 'Detective') myTurn = true;
                if(state.phase === 'doctor_turn' && role === 'Doctor') myTurn = true;
                if(state.phase === 'day') myTurn = true;
            }

            // Button visibility
            const btn = document.getElementById('confirm-btn');
            if(myTurn) {
                btn.style.display = 'block';
                btn.innerText = (state.phase === 'day') ? "VOTE" : "ENGAGE";
            } else {
                btn.style.display = 'none';
                selectedTarget = null; // Reset selection if turn ended
            }

            // Render Orbit
            const orbit = document.getElementById('orbit-container');
            orbit.innerHTML = '';
            const total = state.players.length;
            
            // Build Intel Map default if empty
            if(Object.keys(intelMap).length === 0) {
                state.players.forEach(p => intelMap[p.id] = "?");
            }

            state.players.forEach((p, i) => {
                const angle = (i / total) * 2 * Math.PI - (Math.PI/2);
                const x = 50 + (38 * Math.cos(angle));
                const y = 45 + (38 * Math.sin(angle));
                
                const div = document.createElement('div');
                div.className = `player-node ${p.isAlive ? 'alive' : 'dead'} ${selectedTarget === p.id ? 'selected' : ''}`;
                div.style.left = `${x}%`;
                div.style.top = `${y}%`;
                div.onclick = () => { if(myTurn && p.isAlive) selectTarget(p.id); };
                
                div.innerHTML = `
                    <div class="node-circle">${p.name[0]}</div>
                    <div class="node-name">${p.name}</div>
                `;
                orbit.appendChild(div);
            });

            // Intel List (Sheriff Only)
            const intelPanel = document.getElementById('intel-panel');
            if(role === 'Detective' && amAlive) {
                intelPanel.style.display = 'block';
                // Update names in map in case of join
                state.players.forEach(p => { if(!intelMap[p.id]) intelMap[p.id] = "?"; });
                renderIntelList(state.players);
            } else {
                intelPanel.style.display = 'none';
            }
        }

        function renderIntelList(playersList) {
            // Need the full list of players to map names to IDs
            if(!playersList) return; // Wait for next update
            
            const list = document.getElementById('intel-list');
            list.innerHTML = '';
            
            playersList.forEach(p => {
                if(p.id === myId) return; // Don't show self
                const status = intelMap[p.id] || "?";
                const colorClass = status === 'MAFIA' ? 'status-mafia' : (status === 'INNOCENT' ? 'status-innocent' : 'status-unknown');
                
                const row = document.createElement('div');
                row.className = 'intel-row';
                row.innerHTML = `<span>${p.name}</span> <span class="${colorClass}">${status}</span>`;
                list.appendChild(row);
            });
        }

        function selectTarget(id) {
            selectedTarget = id;
            document.querySelectorAll('.player-node').forEach(el => el.classList.remove('selected'));
            // Find specific element (using click event visual update mostly)
            // Force redraw logic is inside updateGameUI, but for instant feedback:
            // We just wait for user to press button.
            // Highlight locally:
            const nodes = document.getElementById('orbit-container').children;
            // Iterate to find matching
             // Simplified: just wait for server update or trust the confirm button visual
        }

        function confirmAction() {
            if(!selectedTarget) { showAlert("SELECT TARGET FIRST"); return; }
            
            if(isHost) processAction(myId, selectedTarget);
            else conn.send({ type: 'action', targetId: selectedTarget });

            document.getElementById('confirm-btn').style.display = 'none'; // Hide after click
            showAlert("COMMAND SENT");
        }

        function updateTimer(t) {
            const el = document.getElementById('timer-display');
            el.innerText = t;
            el.style.color = (t <= 5) ? 'var(--neon-red)' : '#fff';
        }

        function showAlert(msg) {
            const el = document.getElementById('alert-overlay');
            el.innerText = msg;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 3000);
        }

        function copyId() {
            navigator.clipboard.writeText(document.getElementById('lobby-id').innerText);
            alert("ID COPIED");
        }

    </script>
</body>
</html>
